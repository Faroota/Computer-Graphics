function setup()
{
	UI = {};
	UI.tabs = [];
	UI.titleLong = 'Ray Tracer';
	UI.titleShort = 'RayTracerSimple';
	UI.numFrames = 1000;
	UI.maxFPS = 24;
	UI.renderWidth = 1600;
	UI.renderHeight = 800;

	UI.tabs.push(
		{
		visible: true,
		type: `x-shader/x-fragment`,
		title: `RaytracingDemoFS - GL`,
		id: `RaytracingDemoFS`,
		initialValue: `#define SOLUTION_CYLINDER_AND_PLANE
#define SOLUTION_MATERIAL
#define SOLUTION_SHADOW
#define SOLUTION_REFLECTION_REFRACTION
#define SOLUTION_FRESNEL

precision highp float;
uniform ivec2 viewport; 

struct PointLight {
  vec3 position;
  vec3 color;
};

struct Material {
  vec3  diffuse;
  vec3  specular;
  float glossiness;
#ifdef SOLUTION_MATERIAL
  // Put the variables for reflection and refraction here
	float reflection;
	float refraction;
	float IOR; //https://pixelandpoly.com/ior.html
#else
#endif
};

struct Sphere {
  vec3 position;
  float radius;
  Material material;
};

struct Plane {
  vec3 normal;
  float d;
  Material material;
};

struct Cylinder {
  vec3 position;
  vec3 direction;  
  float radius;
  Material material;
};

const int lightCount = 2;
const int sphereCount = 3;
const int planeCount = 1;
const int cylinderCount = 2;

struct Scene {
  vec3 ambient;
  PointLight[lightCount] lights;
  Sphere[sphereCount] spheres;
  Plane[planeCount] planes;
  Cylinder[cylinderCount] cylinders;
};

struct Ray {
  vec3 origin;
  vec3 direction;
};

// Contains all information pertaining to a ray/object intersection
struct HitInfo {
  bool hit;
  float t;
  vec3 position;
  vec3 normal;
  Material material;
  bool enteringPrimitive;
};

HitInfo getEmptyHit() {
  return HitInfo(
    false, 
    0.0, 
    vec3(0.0), 
    vec3(0.0), 
#ifdef SOLUTION_MATERIAL
	 Material(vec3(0.0), vec3(0.0), 0.0,  0.0,0.0,0.0),
#else
  	// Depending on the material definition extension you make, this constructor call might need to be extened as well
    Material(vec3(0.0), vec3(0.0), 0.0),
#endif
    false);
}

// Sorts the two t values such that t1 is smaller than t2
void sortT(inout float t1, inout float t2) {
  // Make t1 the smaller t
  if(t2 < t1)  {
    float temp = t1;
    t1 = t2;
    t2 = temp;
  }
}

// Tests if t is in an interval
bool isTInInterval(const float t, const float tMin, const float tMax) {
  return t > tMin && t < tMax;
}

// Get the smallest t in an interval
bool getSmallestTInInterval(float t0, float t1, const float tMin, const float tMax, inout float smallestTInInterval) {
  
  sortT(t0, t1);
  
  // As t0 is smaller, test this first
  if(isTInInterval(t0, tMin, tMax)) {
  	smallestTInInterval = t0;
    return true;
  }
  
  // If t0 was not in the interval, still t1 could be
  if(isTInInterval(t1, tMin, tMax)) {
  	smallestTInInterval = t1;
    return true;
  }  
  
  // None was
  return false;
}

HitInfo intersectSphere(const Ray ray, const Sphere sphere, const float tMin, const float tMax) {
              
    vec3 to_sphere = ray.origin - sphere.position;
  
    float a = dot(ray.direction, ray.direction);
    float b = 2.0 * dot(ray.direction, to_sphere);
    float c = dot(to_sphere, to_sphere) - sphere.radius * sphere.radius;
    float D = b * b - 4.0 * a * c;
    if (D > 0.0)
    {
		float t0 = (-b - sqrt(D)) / (2.0 * a);
		float t1 = (-b + sqrt(D)) / (2.0 * a);
      
      	float smallestTInInterval;
      	if(!getSmallestTInInterval(t0, t1, tMin, tMax, smallestTInInterval)) {
          return getEmptyHit();
        }
      
      	vec3 hitPosition = ray.origin + smallestTInInterval * ray.direction;      
		
		//Checking if we're inside the sphere by checking if the ray's origin is inside. If we are, then the normal 
		//at the intersection surface points towards the center. Otherwise, if we are outside the sphere, then the normal 
		//at the intersection surface points outwards from the sphere's center. This is important for refraction.
      	vec3 normal = 
          	length(ray.origin - sphere.position) < sphere.radius + 0.001? 
          	-normalize(hitPosition - sphere.position): 
      		normalize(hitPosition - sphere.position);      
		
		//Checking if we're inside the sphere by checking if the ray's origin is inside, but this time for IOR bookkeeping. 
		//If we are inside, set a flag to say we're leaving. If we are outside, set the flag to say we're entering.
		//This is also important for refraction.
		bool enteringPrimitive = 
          	length(ray.origin - sphere.position) < sphere.radius + 0.001? 
          	false:
		    true; 

        return HitInfo(
          	true,
          	smallestTInInterval,
          	hitPosition,
          	normal,
          	sphere.material,
			enteringPrimitive);
    }
    return getEmptyHit();
}

HitInfo intersectPlane(const Ray ray,const Plane plane, const float tMin, const float tMax) {
#ifdef SOLUTION_CYLINDER_AND_PLANE
	
	//source: (T Funkhouser, 2000)
	//Source: (T Ritschel, 2019)
	//plane equatin is: t= D-(N.P0) /(N.D) OR = - (P0.N +D)/(V.N)
	// if the denominator == 0, there won't be any solution! so we need to exclude it 
	
		float c = dot(ray.direction, plane.normal);
	
	if ( c <= 0.0) { 
		//solve the equation
		float d= (dot(ray.origin, plane.normal) + plane.d )/ dot(ray.direction, plane.normal);
		float t = d;
		
		// get hitPosition (where the ray hits the plnae/ray plane intersection)
		vec3 hitPosition = ray.origin + t * ray.direction;      
  
		//find normal
		//product bwteen normal line and another points (ray.origin-hitPosition) will give us normal line for the hitPosition
		vec3 normal = normalize(plane.normal*(ray.origin-hitPosition));
	
		//return back hit information 
		return HitInfo(
			true,
			t, //we have only one solution
			hitPosition,
			normal, //return the normal 
			plane.material,
			true);
		}
	
	
#endif  
    return getEmptyHit();
}

float lengthSquared(vec3 x) {
  return dot(x, x);
}

HitInfo intersectCylinder(const Ray ray, const Cylinder cylinder, const float tMin, const float tMax) {
#ifdef SOLUTION_CYLINDER_AND_PLANE
	//source: (Zorin, 1999) Ray Tracing 
	//cylinder equation = (p-pa+vt-(va,p-pa+vt)va)^2 -r^2 =0
	//simplify for: At^2 +Bt+C=0 --> (-B ± √(B^2 – A * C)) / A
	
	// to simplify thigs, I breaked the equation down
		vec3 toCylinder = ray.origin - cylinder.position; //∆p
		float d = dot(ray.direction, cylinder.direction); //V.Va
		vec3 a = ray.direction - d* cylinder.direction; //V-(v.va)va)
		float c = dot(toCylinder, cylinder.direction); // (∆p.va)

	//Get the value of each polynomial
	float polynomialA = lengthSquared(a); //a*a = V-(v.va)va)^2
	float polynomialB = 2.0 * dot(a, (toCylinder - c * cylinder.direction)); // 2*(v − (v,va )va ,∆p − (∆p,va )va)
	float polynomialC  = lengthSquared(toCylinder - c * cylinder.direction) - (cylinder.radius * cylinder.radius); //(∆p−(∆p,va)va)^2 −r^2
					
	//solve fot t using t = (-b ± √(b^2 – a * c)) / a
	//sqrt
	float discriminant = polynomialB * polynomialB - 4.0 * polynomialA * polynomialC;
	
	// the answer has two values, + and -, so we have two solutions
	if (discriminant > 0.0) {
		float t0 = (-polynomialB + sqrt(discriminant)) / (2.0 * polynomialA);
		float t1 = (-polynomialB - sqrt(discriminant)) / (2.0 * polynomialA);

		float smallestTInInterval; //we need the smallest t
		if(!getSmallestTInInterval(t0, t1, tMin, tMax, smallestTInInterval)) {
			return getEmptyHit();
		}
		
		// get hitPosition (where the ray hits the cylinder/ray cylinder intersection)
		vec3 hitPosition = ray.origin + smallestTInInterval * ray.direction;      

		// find cylinder normal
		//normal = (hit - position) - diroction dot (hit - position) 
		vec3 normal = normalize((hitPosition-cylinder.position)-(dot(cylinder.direction,(hitPosition-cylinder.position))*cylinder.direction));
		 
		//return hit info
		return HitInfo(
			true,
			smallestTInInterval,
			hitPosition,
			normal,
			cylinder.material,
			true);
	}
	
#endif  
    return getEmptyHit();
}

HitInfo getBetterHitInfo(const HitInfo oldHitInfo, const HitInfo newHitInfo) {
	if(newHitInfo.hit)
  		if(newHitInfo.t < oldHitInfo.t)  // No need to test for the interval, this has to be done per-primitive
          return newHitInfo;
  	return oldHitInfo;
}

HitInfo intersectScene(const Scene scene, const Ray ray, const float tMin, const float tMax) {
  HitInfo bestHitInfo;
  bestHitInfo.t = tMax;
  bestHitInfo.hit = false;
  for (int i = 0; i < cylinderCount; ++i) {
    bestHitInfo = getBetterHitInfo(bestHitInfo, intersectCylinder(ray, scene.cylinders[i], tMin, tMax));
  }
  for (int i = 0; i < sphereCount; ++i) {
    bestHitInfo = getBetterHitInfo(bestHitInfo, intersectSphere(ray, scene.spheres[i], tMin, tMax));
  }
  for (int i = 0; i < planeCount; ++i) {
    bestHitInfo = getBetterHitInfo(bestHitInfo, intersectPlane(ray, scene.planes[i], tMin, tMax));
  }
  
  return bestHitInfo;
}

vec3 shadeFromLight(
  const Scene scene,
  const Ray ray,
  const HitInfo hit_info,
  const PointLight light)
{ 
  vec3 hitToLight = light.position - hit_info.position;
  
  vec3 lightDirection = normalize(hitToLight);
  vec3 viewDirection = normalize(hit_info.position - ray.origin);
  vec3 reflectedDirection = reflect(viewDirection, hit_info.normal);
  float diffuse_term = max(0.0, dot(lightDirection, hit_info.normal));
  float specular_term  = pow(max(0.0, dot(lightDirection, reflectedDirection)), hit_info.material.glossiness);

#ifdef SOLUTION_SHADOW
  // Put your shadow test here
	//Source: (K Bala, 2012)
	//in order to calculate shadows, we need to understand the camera position, light position, and surfece type
	//where is the light direction? we need to find it in order to find its reflection (shadow)
	//typical error examples, shadow starting point might wrong due to the distance calculation,
	//in order to prevent that we need to change the start point
	//another typical error, shadowing the whole image! we need to know which t does the ray intersects with?
	//as we don't whant to shadow the whole sceen
	//we need to define the max in order to know how far are the objects located
	//float max = distance(light.position, hitInfo.position);
	
	// shadow test:
	float visibility = 1.0;

	Ray shadowRay;
	shadowRay.origin = hit_info.position;
	shadowRay.direction = lightDirection;
	HitInfo shadowHitInfo = intersectScene(scene, shadowRay, 0.001, 100000.0);
	
	if (shadowHitInfo.hit) {
		visibility = 0.0;
	return visibility * light.color *(specular_term * hit_info.material.specular +
      		diffuse_term * hit_info.material.diffuse);} //it's going to be zero
	
#else
	
  float visibility = 1.0;
#endif
  
  return 	visibility * 
    		light.color * (
    		specular_term * hit_info.material.specular +
      		diffuse_term * hit_info.material.diffuse);
}

vec3 background(const Ray ray) {
  // A simple implicit sky that can be used for the background
  return vec3(0.2) + vec3(0.8, 0.6, 0.5) * max(0.0, ray.direction.y);
}

// It seems to be a WebGL issue that the third parameter needs to be inout instea dof const on Tobias' machine
vec3 shade(const Scene scene, const Ray ray, inout HitInfo hitInfo) {
  
  	if(!hitInfo.hit) {
  		return background(ray);
  	}
  
    vec3 shading = scene.ambient * hitInfo.material.diffuse;
    for (int i = 0; i < lightCount; ++i) {
        shading += shadeFromLight(scene, ray, hitInfo, scene.lights[i]); 
    }
    return shading;
}


Ray getFragCoordRay(const vec2 frag_coord) {
  	float sensorDistance = 1.0;
  	vec2 sensorMin = vec2(-1, -0.5);
  	vec2 sensorMax = vec2(1, 0.5);
  	vec2 pixelSize = (sensorMax- sensorMin) / vec2(viewport.x, viewport.y);
  	vec3 origin = vec3(0, 0, sensorDistance);
    vec3 direction = normalize(vec3(sensorMin + pixelSize * frag_coord, -sensorDistance));  
  
  	return Ray(origin, direction);
}

float fresnel(const vec3 viewDirection, const vec3 normal) {
#ifdef SOLUTION_FRESNEL
	// Put your code to compute the Fresnel effect here
	return dot(viewDirection, normal);
	//return 1.0;
	
#else
	return 1.0;
#endif
}

vec3 colorForFragment(const Scene scene, const vec2 fragCoord) {
      
    Ray initialRay = getFragCoordRay(fragCoord);  
  	HitInfo initialHitInfo = intersectScene(scene, initialRay, 0.001, 10000.0);  
  	vec3 result = shade(scene, initialRay, initialHitInfo);
	
  	Ray currentRay;
  	HitInfo currentHitInfo;
  	
  	// Compute the reflection
  	currentRay = initialRay;
  	currentHitInfo = initialHitInfo;
  	
  	// The initial strength of the reflection
  	float reflectionWeight = 1.0;
  	
  	const int maxReflectionStepCount = 2;
  	for(int i = 0; i < maxReflectionStepCount; i++) {
      
      if(!currentHitInfo.hit) break;
      
#ifdef SOLUTION_REFLECTION_REFRACTION
  // Put your reflection weighting code here
		
		reflectionWeight *= 0.5;
#else
      
#endif
      
#ifdef SOLUTION_FRESNEL
#else
      // Replace with Fresnel code
      reflectionWeight *= 0.5;
#endif
      
      Ray nextRay;
#ifdef SOLUTION_REFLECTION_REFRACTION
	// Put your code to compute the reflection ray
		
		//reflection direction is opposite to the object.
		//set the direction
		//reflectionWeight *= currentHitInfo.material.reflection; //already set
		nextRay.direction= reflect(currentRay.direction, currentHitInfo.normal);
		currentRay=nextRay;
		
#else
	
#endif
      currentRay = nextRay;
      
      currentHitInfo = intersectScene(scene, currentRay, 0.001, 10000.0);      
            
      result += reflectionWeight * shade(scene, currentRay, currentHitInfo);
    }
  
  	// Compute the refraction
  	currentRay = initialRay;  
  	currentHitInfo = initialHitInfo;
   
  	// The initial medium is air
  	float currentIOR = 1.0;

  	// The initial strength of the refraction.
  	float refractionWeight = 1.0;
  
  	const int maxRefractionStepCount = 2;
  	for(int i = 0; i < maxRefractionStepCount; i++) {
      
#ifdef SOLUTION_REFLECTION_REFRACTION
		reflectionWeight *= currentHitInfo.material.refraction;
		
#else
      // Replace with Fresnel code
      reflectionWeight *= 0.5;      
#endif

#ifdef SOLUTION_FRESNEL
#else
      // Put Fresnel code here
#endif      

      Ray nextRay;


#ifdef SOLUTION_REFLECTION_REFRACTION      
	  //This solution only expects the ray to be in one primitive at a time, and this is expected of student. 
	  //That is, on exit it'll assume that the ray is in air.
	  // Put your code to compute the reflection ray and track the IOR
		
		//nextRay.direction= reflect(currentRay.direction, currentHitInfo.normal);
		//air refraction = 1, glass= 1.5
		
			float sourceIOR= currentHitInfo.material.IOR;
			float ratio=currentIOR/sourceIOR;
		
			//https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/refract.xhtml
			vec3 reflectionDirection= refract(currentRay.direction,currentHitInfo.normal, ratio );
			nextRay= Ray(currentHitInfo.position,reflectionDirection);
			currentRay=nextRay;
		
		
#else
	float sourceIOR;
	float destIOR;
	
#endif
      currentHitInfo = intersectScene(scene, currentRay, 0.001, 10000.0);
            
      result += refractionWeight * shade(scene, currentRay, currentHitInfo);
      
      if(!currentHitInfo.hit) break;
    }
  return result;
}

Material getDefaultMaterial() {
#ifdef SOLUTION_MATERIAL
	//diffuse, specular, glossiness, reflection, refraction, IOR
	return Material(vec3(0.0), vec3(0.0), 1.0,  0.0,0.0,0.0);
#else
  return Material(vec3(0.3), vec3(0), 1.0);
#endif
}

Material getPaperMaterial() {
#ifdef SOLUTION_MATERIAL
  // Replace by your definition of a paper material
	//paper is white and has no reflection
	//diffuse is almost white, specular is 0 or almost 0
	//glossiness is zero as papers are matte, however, to avoid backness I've setted it to very samll number
	//reflection & refraction are zeros as well 
	return Material(vec3(0.85), vec3(0.0), 0.0000001,  0.0,0.0,0.0);
#else
  return getDefaultMaterial();
#endif
}

Material getPlasticMaterial() {
#ifdef SOLUTION_MATERIAL
  // Replace by your definition of a plastic material
	//plastic is very shiny & should be yellow
	//diffuse = yellow RGB = 1,1,0
	//IOR = 1.460 accoring to https://pixelandpoly.com/ior.html
	return Material(vec3(1, 0.7, 0.0), vec3(0.6), 10.0,  0.0,0.0, 1.460);
#else
  return getDefaultMaterial();
#endif
}

Material getGlassMaterial() {
#ifdef SOLUTION_MATERIAL
  // Replace by your definition of a glass material
	//glass has no color, very shiny (more than plastis)
	//IOR = 1.5 accoring to https://pixelandpoly.com/ior.html
	return Material(vec3(0.0), vec3(0.0), 17.0,  0.0,0.0, 1.5);
#else
  return getDefaultMaterial();
#endif
}

Material getSteelMirrorMaterial() {
#ifdef SOLUTION_MATERIAL
  // Replace by your definition of a steel mirror material
	//mirror is gray, shiny but not as the glass
	//no IOR
	return Material(vec3(0.2), vec3(1.0), 10.0 ,  0.0,0.0,0.0);
#else
  return getDefaultMaterial();
#endif
}

vec3 tonemap(const vec3 radiance) {
  const float monitorGamma = 2.0;
  return pow(radiance, vec3(1.0 / monitorGamma));
}

void main()
{
    // Setup scene
    Scene scene;
  	scene.ambient = vec3(0.12, 0.15, 0.2);
  
    // Lights
    scene.lights[0].position = vec3(5, 15, -5);
    scene.lights[0].color    = 0.5 * vec3(0.9, 0.5, 0.1);
    
  	scene.lights[1].position = vec3(-15, 5, 2);
    scene.lights[1].color    = 0.5 * vec3(0.1, 0.3, 1.0);
  
    // Primitives
    scene.spheres[0].position            	= vec3(10, -5, -16);
    scene.spheres[0].radius              	= 6.0;
    scene.spheres[0].material 				= getPaperMaterial();
    
  	scene.spheres[1].position            	= vec3(-7, -2, -13);
    scene.spheres[1].radius             	= 4.0;
    scene.spheres[1].material				= getPlasticMaterial();
  
    scene.spheres[2].position            	= vec3(0, 0.5, -5);
    scene.spheres[2].radius              	= 2.0;
    scene.spheres[2].material   			= getGlassMaterial();

  	scene.planes[0].normal            		= normalize(vec3(0, 0.8, 0));
  	scene.planes[0].d              			= -4.5;
    scene.planes[0].material				= getSteelMirrorMaterial();
  
  	scene.cylinders[0].position            	= vec3(-1, 1, -26);
  	scene.cylinders[0].direction            = normalize(vec3(-2, 2, -1));
  	scene.cylinders[0].radius         		= 1.5;
    scene.cylinders[0].material				= getPaperMaterial();
  
  	scene.cylinders[1].position            	= vec3(4, 1, -5);
  	scene.cylinders[1].direction            = normalize(vec3(1, 4, 1));
  	scene.cylinders[1].radius         		= 0.4;
    scene.cylinders[1].material				= getPlasticMaterial();

  // compute color for fragment
  gl_FragColor.rgb = tonemap(colorForFragment(scene, gl_FragCoord.xy));
  gl_FragColor.a = 1.0;

}
`,
		description: ``,
		wrapFunctionStart: ``,
		wrapFunctionEnd: ``
	});

	UI.tabs.push(
		{
		visible: false,
		type: `x-shader/x-vertex`,
		title: `RaytracingDemoVS - GL`,
		id: `RaytracingDemoVS`,
		initialValue: `attribute vec3 position;
    uniform mat4 modelViewMatrix;
    uniform mat4 projectionMatrix;
  
    void main(void) {
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
`,
		description: ``,
		wrapFunctionStart: ``,
		wrapFunctionEnd: ``
	});

	 return UI; 
}//!setup

var gl;
function initGL(canvas) {
	try {
		gl = canvas.getContext("experimental-webgl");
		gl.viewportWidth = canvas.width;
		gl.viewportHeight = canvas.height;
	} catch (e) {
	}
	if (!gl) {
		alert("Could not initialise WebGL, sorry :-(");
	}
}

function getShader(gl, id) {
	var shaderScript = document.getElementById(id);
	if (!shaderScript) {
		return null;
	}

	var str = "";
	var k = shaderScript.firstChild;
	while (k) {
		if (k.nodeType == 3) {
			str += k.textContent;
		}
		k = k.nextSibling;
	}

	var shader;
	if (shaderScript.type == "x-shader/x-fragment") {
		shader = gl.createShader(gl.FRAGMENT_SHADER);
	} else if (shaderScript.type == "x-shader/x-vertex") {
		shader = gl.createShader(gl.VERTEX_SHADER);
	} else {
		return null;
	}

    console.log(str);
	gl.shaderSource(shader, str);
	gl.compileShader(shader);

	if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
		alert(gl.getShaderInfoLog(shader));
		return null;
	}

	return shader;
}

function RaytracingDemo() {
}

RaytracingDemo.prototype.initShaders = function() {

	this.shaderProgram = gl.createProgram();

	gl.attachShader(this.shaderProgram, getShader(gl, "RaytracingDemoVS"));
	gl.attachShader(this.shaderProgram, getShader(gl, "RaytracingDemoFS"));
	gl.linkProgram(this.shaderProgram);

	if (!gl.getProgramParameter(this.shaderProgram, gl.LINK_STATUS)) {
		alert("Could not initialise shaders");
	}

	gl.useProgram(this.shaderProgram);

	this.shaderProgram.vertexPositionAttribute = gl.getAttribLocation(this.shaderProgram, "position");
	gl.enableVertexAttribArray(this.shaderProgram.vertexPositionAttribute);

	this.shaderProgram.projectionMatrixUniform = gl.getUniformLocation(this.shaderProgram, "projectionMatrix");
	this.shaderProgram.modelviewMatrixUniform = gl.getUniformLocation(this.shaderProgram, "modelViewMatrix");
}

RaytracingDemo.prototype.initBuffers = function() {
	this.triangleVertexPositionBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, this.triangleVertexPositionBuffer);
	
	var vertices = [
		 -1,  -1,  0,
		 -1,  1,  0,
		 1,  1,  0,

		 -1,  -1,  0,
		 1,  -1,  0,
		 1,  1,  0,
	 ];
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
	this.triangleVertexPositionBuffer.itemSize = 3;
	this.triangleVertexPositionBuffer.numItems = 3 * 2;
}

RaytracingDemo.prototype.drawScene = function() {
			
	var perspectiveMatrix = new J3DIMatrix4();	
	perspectiveMatrix.setUniform(gl, this.shaderProgram.projectionMatrixUniform, false);

	var modelViewMatrix = new J3DIMatrix4();	
	modelViewMatrix.setUniform(gl, this.shaderProgram.modelviewMatrixUniform, false);
		
	gl.bindBuffer(gl.ARRAY_BUFFER, this.triangleVertexPositionBuffer);
	gl.vertexAttribPointer(this.shaderProgram.vertexPositionAttribute, this.triangleVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
	
	gl.uniform2iv(gl.getUniformLocation(this.shaderProgram, "viewport"), [getRenderTargetWidth(), getRenderTargetHeight()]);
	
	gl.drawArrays(gl.TRIANGLES, 0, this.triangleVertexPositionBuffer.numItems);
}

RaytracingDemo.prototype.run = function() {
	this.initShaders();
	this.initBuffers();

	gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
	gl.clear(gl.COLOR_BUFFER_BIT);

	this.drawScene();
};

function init() {	
	

	env = new RaytracingDemo();	
	env.run();

    return env;
}

function compute(canvas)
{
    env.initShaders();
    env.initBuffers();

    gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
    gl.clear(gl.COLOR_BUFFER_BIT);

    env.drawScene();
}

